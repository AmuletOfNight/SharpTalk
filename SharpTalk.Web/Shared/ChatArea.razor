@using SharpTalk.Shared
@using SharpTalk.Shared.DTOs
@using SharpTalk.Shared.Enums
@using SharpTalk.Web.Services
@using System.Security.Claims
@using Microsoft.AspNetCore.Components.Authorization
@using Microsoft.AspNetCore.Components.Forms
@implements IAsyncDisposable
@inject ChatService ChatService
@inject AuthenticationStateProvider AuthStateProvider
@inject IJSRuntime JSRuntime
@inject UrlUtilityService UrlUtilityService
@inject UserService UserService
@inject ChannelService ChannelService

<div class="chat-area">
    @if (Channel?.Type == ChannelType.Group)
    {
        <div class="group-dm-header">
            <div class="group-dm-info">
                <div class="group-dm-avatar-icon">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path>
                        <circle cx="9" cy="7" r="4"></circle>
                        <path d="M23 21v-2a4 4 0 0 0-3-3.87"></path>
                        <path d="M16 3.13a4 4 0 0 1 0 7.75"></path>
                    </svg>
                </div>
                <div>
                    <div class="group-dm-name">@Channel.Name</div>
                    <div class="group-dm-members">@Channel.MemberCount members</div>
                </div>
            </div>
            <div class="group-dm-actions">
                <button class="btn btn-sm btn-outline-secondary" @onclick="OpenGroupSettings" title="Group Settings">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <circle cx="12" cy="12" r="3"></circle>
                        <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path>
                    </svg>
                </button>
            </div>
        </div>
    }
    <div class="messages-list" id="messagesList">
        @foreach (var msg in Messages)
        {
            var isMine = msg.UserId == currentUserId;
            var isNew = msg.Timestamp > lastSentTimestamp;
            var animationClass = isNew ? (isMine ? "fly-in" : "slide-in-left") : "";
            <div @key="msg.Id" class='message-item @(isMine ? "message-mine" : "message-others") @animationClass'>
            
                <div class="message-body">
                    <div class="message-content-wrapper">
                        @if (!isMine)
                        {
                            <img src="@UrlUtilityService.GetAvatarUrl(msg.AvatarUrl, "s")"
                                 class="message-avatar @(msg.UserStatus.ToLower())"
                                 alt="@msg.Username" />
                        }
                        <div class="bubble-container">
                            <div class="message-author-inline">@msg.Username</div>
                            <div class="message-content">@msg.Content</div>
                            @if (msg.Attachments.Any())
                            {
                                <div class="message-attachment-divider"></div>
                                <div class="message-attachments">
                                    @foreach (var attachment in msg.Attachments)
                                    {
                                        <div class="attachment-item">
                                            @if (IsImage(attachment.FileType))
                                            {
                                                <img src="@UrlUtilityService.GetFileUrl(attachment.FileUrl)"
                                                     class="attachment-image"
                                                     alt="@attachment.FileName"
                                                     @onclick="() => OpenImagePreview(attachment)" />
                                            }
                                            else
                                            {
                                                <div class="attachment-file" @onclick="() => DownloadFile(attachment)">
                                                    <span class="file-icon">@GetFileIcon(attachment.FileType)</span>
                                                    <div class="file-info">
                                                        <span class="file-name">@attachment.FileName</span>
                                                        <span class="file-size">@FormatFileSize(attachment.FileSize)</span>
                                                    </div>
                                                </div>
                                            }
                                        </div>
                                    }
                                </div>
                            }
                            <div class="message-timestamp-inline">@msg.Timestamp.ToLocalTime().ToString("t")</div>
                        </div>
                        @if (isMine)
                        {
                            <img src="@UrlUtilityService.GetAvatarUrl(msg.AvatarUrl, "s")"
                                 class="message-avatar @(msg.UserStatus.ToLower())"
                                 alt="@msg.Username" />
                        }
                    </div>
                </div>
            </div>
        }
    </div>

    <div class="typing-indicator">
        @if (TypingUsers.Any() || isTypingFadingOut)
        {
            <small class="text-muted italic @(isTypingFadingOut ? "fade-out" : "")">
                @((isTypingFadingOut ? lastTypingText : string.Join(", ", TypingUsers.Values))) @((isTypingFadingOut ? (lastTypingCount == 1 ? "is" : "are") : (TypingUsers.Count == 1 ? "is" : "are"))) typing...
            </small>
        }
    </div>

    <div class="message-input">
        @if (selectedFiles.Any())
        {
            <div class="file-preview-area">
                @foreach (var file in selectedFiles)
                {
                    <div class="file-preview-card">
                        <div class="file-preview-icon @GetFileIconClass(file.ContentType)">
                            <span>@GetFileIconEmoji(file.ContentType)</span>
                        </div>
                        <div class="file-preview-info">
                            <span class="file-preview-name" title="@file.Name">@file.Name</span>
                            <span class="file-preview-size">@FormatFileSize(file.Size)</span>
                        </div>
                        <button type="button" class="file-preview-remove" @onclick="() => RemoveFile(file)" title="Remove file">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <line x1="18" y1="6" x2="6" y2="18"></line>
                                <line x1="6" y1="6" x2="18" y2="18"></line>
                            </svg>
                        </button>
                    </div>
                }
            </div>
        }
        @if (!string.IsNullOrEmpty(uploadErrorMessage))
        {
            <div class="upload-error-message">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <circle cx="12" cy="12" r="10"></circle>
                    <line x1="12" y1="8" x2="12" y2="12"></line>
                    <line x1="12" y1="16" x2="12.01" y2="16"></line>
                </svg>
                <span>@uploadErrorMessage</span>
                <button type="button" @onclick="() => uploadErrorMessage = null" class="close-error">Ã—</button>
            </div>
        }
        @if (Channel != null && !Channel.CanMessage)
        {
             <div class="alert alert-warning m-2 d-flex align-items-center" role="alert">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" class="bi bi-exclamation-triangle-fill flex-shrink-0 me-2" viewBox="0 0 16 16">
                    <path d="M8.982 1.566a1.13 1.13 0 0 0-1.96 0L.165 13.233c-.457.778.091 1.767.98 1.767h13.713c.889 0 1.438-.99.98-1.767L8.982 1.566zM8 5c.535 0 .954.462.9.995l-.35 3.507a.552.552 0 0 1-1.1 0L7.1 5.995A.905.905 0 0 1 8 5zm.002 6a1 1 0 1 1 0 2 1 1 0 0 1 0-2z"/>
                </svg>
                <div>
                    You must be a part of at least one shared workspace to message with this person.
                </div>
            </div>
        }
        else
        {

            <form @onsubmit="SendMessage">
                <div class="unified-chat-input">
                    <div class="speech-bubble-input">
                        <label class="attach-btn-inline" title="Attach files">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M21.44 11.05l-9.19 9.19a6 6 0 0 1-8.49-8.49l9.19-9.19a4 4 0 0 1 5.66 5.66l-9.2 9.19a2 2 0 0 1-2.83-2.83l8.49-8.48"></path>
                            </svg>
                            <InputFile OnChange="HandleFileSelect" multiple accept="@string.Join(",", FileUploadConstants.AllowedMimeTypes)" />
                        </label>
                        <input type="text" class="message-input-field" placeholder="Message #@(Channel?.Name ?? "Channel")" @bind="newMessage"
                            @bind:event="oninput" />
                        <button type="submit" class="send-btn" title="Send message" disabled="@(!CanSendMessage())">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <line x1="22" y1="2" x2="11" y2="13"></line>
                                <polygon points="22 2 15 22 11 13 2 9 22 2"></polygon>
                            </svg>
                        </button>
                    </div>
                </div>
            </form>
        }
    </div>
</div>

<!-- Image Preview Modal -->
@if (previewAttachment != null)
{
    <div class="image-preview-modal" @onclick="CloseImagePreview">
        <div class="image-preview-content" @onclick:stopPropagation>
            <img src="@UrlUtilityService.GetFileUrl(previewAttachment.FileUrl)" alt="@previewAttachment.FileName" />
            <div class="image-preview-actions">
                <button type="button" class="btn btn-secondary" @onclick="CloseImagePreview">Close</button>
                <button type="button" class="btn btn-primary" @onclick="() => DownloadFile(previewAttachment)">Download</button>
            </div>
        </div>
    </div>
}

@code {
    [Parameter]
    public ChannelDto? Channel { get; set; }

    [Parameter]
    public EventCallback<ChannelDto> OnOpenGroupSettings { get; set; }

    private int ChannelId => Channel?.Id ?? 0;

    private List<MessageDto> Messages = new List<MessageDto>();
    private string _newMessage = string.Empty;
    private string newMessage
    {
        get => _newMessage;
        set
        {
            if (_newMessage != value)
            {
                _newMessage = value;
                HandleTyping();
            }
        }
    }
    private int _currentChannelId;
    private int currentUserId;
    private Dictionary<int, string> TypingUsers = new Dictionary<int, string>();
    private System.Timers.Timer? typingTimer;
    private bool isTypingSent = false;
    private bool isTypingFadingOut = false;
    private string? lastTypingText;
    private int lastTypingCount = 0;
    private List<IBrowserFile> selectedFiles = new List<IBrowserFile>();
    private List<AttachmentDto> uploadedAttachments = new List<AttachmentDto>();
    private AttachmentDto? previewAttachment;
    private string? uploadErrorMessage;
    private DateTime lastSentTimestamp = DateTime.MinValue;

    protected override async Task OnInitializedAsync()
    {
        var authState = await AuthStateProvider.GetAuthenticationStateAsync();
        var userIdStr = authState.User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
        int.TryParse(userIdStr, out currentUserId);

        ChatService.OnMessageReceived += HandleMessageReceived;
        ChatService.OnUserTyping += HandleUserTyping;
        ChatService.OnUserStatusChanged += HandleUserStatusChanged;
        await ChatService.InitializeAsync();
    }

    protected override async Task OnParametersSetAsync()
    {
        if (ChannelId != _currentChannelId)
        {
            if (_currentChannelId > 0)
            {
                await ChatService.LeaveChannelAsync(_currentChannelId);
            }

            _currentChannelId = ChannelId;
            Messages.Clear();
            TypingUsers.Clear();
            isTypingFadingOut = false;
            lastTypingText = null;
            lastTypingCount = 0;

            // Only load history and join if channel ID is valid
            if (ChannelId > 0)
            {
                // Load history
                var history = await ChatService.GetMessageHistoryAsync(ChannelId);
                Messages.AddRange(history);
                StateHasChanged();
                await ScrollToBottom();

                await ChatService.JoinChannelAsync(ChannelId);
            }
        }
    }

    private async void HandleMessageReceived(MessageDto message)
    {
        if (message.ChannelId == ChannelId)
        {
            Messages.Add(message);
            // Clear typing indicator for this user if it exists
            if (TypingUsers.ContainsKey(message.UserId))
            {
                TypingUsers.Remove(message.UserId);
            }
            await InvokeAsync(async () => {
                StateHasChanged();
                await ScrollToBottom();
            });
        }
    }

    private async void HandleUserTyping(int channelId, int userId, string username, bool isTyping)
    {
        if (channelId == ChannelId)
        {
            // Store current typing text and count before any changes
            var currentTypingText = TypingUsers.Any() ? string.Join(", ", TypingUsers.Values) : null;
            var currentTypingCount = TypingUsers.Count;
            
            if (isTyping)
            {
                if (!TypingUsers.ContainsKey(userId))
                {
                    TypingUsers[userId] = username;
                    isTypingFadingOut = false;
                }
            }
            else
            {
                TypingUsers.Remove(userId);
            }

            // Trigger fade-out animation when no more typing users
            if (!TypingUsers.Any() && !isTypingFadingOut && currentTypingText != null)
            {
                // Store the last typing text and count before fading out
                lastTypingText = currentTypingText;
                lastTypingCount = currentTypingCount;
                isTypingFadingOut = true;
                await InvokeAsync(StateHasChanged);
                
                // Remove the indicator after animation completes
                await Task.Delay(300);
                isTypingFadingOut = false;
                lastTypingText = null;
                lastTypingCount = 0;
                await InvokeAsync(StateHasChanged);
            }
            else if (TypingUsers.Any())
            {
                await InvokeAsync(StateHasChanged);
            }
        }
    }

    private async void HandleUserStatusChanged(UserStatusDto status)
    {
        bool changed = false;
        
        // Update message avatars
        foreach (var msg in Messages.Where(m => m.UserId == status.UserId))
        {
            if (msg.UserStatus != status.Status)
            {
                msg.UserStatus = status.Status;
                changed = true;
            }
        }

        // Update channel status if this is a DM with this user
        if (Channel != null && Channel.Type == ChannelType.Direct && Channel.TargetUserId == status.UserId)
        {
            if (Channel.UserStatus != status.Status)
            {
                Channel.UserStatus = status.Status;
                changed = true;
            }
        }

        if (changed)
        {
            await InvokeAsync(StateHasChanged);
        }
    }

    private void HandleTyping()
    {
        // Prevent sending typing indicators to invalid channel (0)
        if (ChannelId <= 0 || string.IsNullOrWhiteSpace(newMessage)) return;

        if (!isTypingSent)
        {
            isTypingSent = true;
            _ = ChatService.SendTypingIndicatorAsync(ChannelId, true);
        }

        if (typingTimer == null)
        {
            typingTimer = new System.Timers.Timer((int)ChatConstants.TypingIndicatorTimeout.TotalMilliseconds);
            typingTimer.AutoReset = false;
            typingTimer.Elapsed += async (s, args) =>
            {
                isTypingSent = false;
                await ChatService.SendTypingIndicatorAsync(ChannelId, false);
                await InvokeAsync(StateHasChanged);
            };
        }
        else
        {
            typingTimer.Stop();
        }
        typingTimer.Start();
    }

    private async Task SendMessage()
    {
        // Prevent sending messages to invalid channel (0)
        if (ChannelId <= 0)
        {
            return;
        }

        bool hasText = !string.IsNullOrWhiteSpace(newMessage);
        bool hasFiles = selectedFiles.Any();

        if (hasText || hasFiles)
        {
            var content = newMessage;
            var filesToSend = new List<IBrowserFile>(selectedFiles);
            
            newMessage = string.Empty;
            selectedFiles.Clear();
            isTypingSent = false;
            typingTimer?.Stop();
            uploadErrorMessage = null;

            // Upload files first if any
            List<int> attachmentIds = new List<int>();
            if (filesToSend.Any())
            {
                StateHasChanged();

                try
                {
                    uploadedAttachments = await ChatService.UploadFilesAsync(filesToSend, ChannelId);
                    attachmentIds = uploadedAttachments.Select(a => a.Id).ToList();

                    if (attachmentIds.Count == 0)
                    {
                        uploadErrorMessage = "Failed to upload files. Message not sent.";
                        newMessage = content;
                        selectedFiles.AddRange(filesToSend);
                        StateHasChanged();
                        return;
                    }
                    
                    if (attachmentIds.Count < filesToSend.Count)
                    {
                        // Some files failed, but some succeeded. We can either proceed or block.
                        // For now we'll proceed but notify. Actually, usually it's better to block if any fail
                        // but if they succeeded in the API they are already saved.
                    }
                }
                catch (Exception ex)
                {
                    uploadErrorMessage = ex.Message;
                    newMessage = content;
                    selectedFiles.AddRange(filesToSend);
                    StateHasChanged();
                    return;
                }
            }

            // Only send the message if there's either text or at least one successful attachment
            if (!string.IsNullOrWhiteSpace(content) || attachmentIds.Any())
            {
                try
                {
                    lastSentTimestamp = DateTime.UtcNow.AddSeconds(-1); // Set slightly before now to catch the incoming message
                    await ChatService.SendMessageAsync(ChannelId, content, attachmentIds);
                    await ChatService.SendTypingIndicatorAsync(ChannelId, false);
                }
                catch (Exception ex)
                {
                    uploadErrorMessage = $"Error sending message: {ex.Message}";
                    
                    // Recover message text so user doesn't lose it
                    if (string.IsNullOrEmpty(newMessage))
                    {
                        newMessage = content;
                    }
                    StateHasChanged();
                }
            }
            StateHasChanged();
            await ScrollToBottom();
        }
    }

    private async Task ScrollToBottom()
    {
        await JSRuntime.InvokeVoidAsync("scrollToBottom", "messagesList");
    }

    private void HandleFileSelect(InputFileChangeEventArgs e)
    {
        uploadErrorMessage = null;
        var files = e.GetMultipleFiles();
        foreach (var file in files)
        {
            // Validate file type
            if (!FileUploadConstants.AllowedMimeTypes.Contains(file.ContentType.ToLower()))
            {
                uploadErrorMessage = $"File '{file.Name}' is not an allowed type.";
                continue;
            }

            // Validate file size
            var isImage = file.ContentType.StartsWith("image/");
            var maxSize = isImage ? FileUploadConstants.MaxImageFileSize : FileUploadConstants.MaxOtherFileSize;
            
            if (file.Size > maxSize)
            {
                uploadErrorMessage = $"File '{file.Name}' exceeds the size limit ({maxSize / (1024 * 1024)}MB).";
                continue; 
            }

            selectedFiles.Add(file);
        }
        StateHasChanged();
    }

    private void RemoveFile(IBrowserFile file)
    {
        selectedFiles.Remove(file);
        StateHasChanged();
    }

    private void OpenImagePreview(AttachmentDto attachment)
    {
        previewAttachment = attachment;
        StateHasChanged();
    }

    private void CloseImagePreview()
    {
        previewAttachment = null;
        StateHasChanged();
    }

    private async Task DownloadFile(AttachmentDto attachment)
    {
        var downloadUrl = await ChatService.DownloadAttachmentAsync(attachment.Id);
        if (!string.IsNullOrEmpty(downloadUrl))
        {
            await JSRuntime.InvokeVoidAsync("downloadFile", downloadUrl, attachment.FileName);
        }
    }

    private bool IsImage(string fileType)
    {
        return fileType.StartsWith("image/");
    }

    private string GetFileIcon(string fileType)
    {
        return fileType switch
        {
            var f when f.StartsWith("image/") => "ðŸ–¼ï¸",
            var f when f.Contains("pdf") => "ðŸ“„",
            var f when f.Contains("word") => "ðŸ“",
            var f when f.Contains("excel") || f.Contains("spreadsheet") => "ðŸ“Š",
            var f when f.Contains("powerpoint") || f.Contains("presentation") => "ðŸ“½",
            var f when f.Contains("zip") || f.Contains("rar") || f.Contains("7z") => "ðŸ“¦",
            var f when f.Contains("text") => "ðŸ“ƒ",
            _ => "ðŸ“Ž"
        };
    }

    private string FormatFileSize(long bytes)
    {
        string[] sizes = { "B", "KB", "MB", "GB" };
        int order = 0;
        double size = bytes;
        while (size >= 1024 && order < sizes.Length - 1)
        {
            order++;
            size = size / 1024;
        }
        return $"{size:0.##} {sizes[order]}";
    }

    private string GetFileIconClass(string? contentType)
    {
        if (string.IsNullOrEmpty(contentType)) return "default";
        
        if (contentType.StartsWith("image/")) return "image";
        if (contentType.Contains("pdf")) return "pdf";
        if (contentType.Contains("word") || contentType.Contains("document") ||
            contentType.Contains("excel") || contentType.Contains("spreadsheet") ||
            contentType.Contains("powerpoint") || contentType.Contains("presentation") ||
            contentType.Contains("text")) return "document";
        if (contentType.Contains("zip") || contentType.Contains("rar") ||
            contentType.Contains("7z") || contentType.Contains("tar") ||
            contentType.Contains("gzip")) return "archive";
        
        return "default";
    }

    private string GetFileIconEmoji(string? contentType)
    {
        if (string.IsNullOrEmpty(contentType)) return "ðŸ“Ž";
        
        if (contentType.StartsWith("image/")) return "ðŸ–¼ï¸";
        if (contentType.Contains("pdf")) return "ðŸ“„";
        if (contentType.Contains("word") || contentType.Contains("document")) return "ðŸ“";
        if (contentType.Contains("excel") || contentType.Contains("spreadsheet")) return "ðŸ“Š";
        if (contentType.Contains("powerpoint") || contentType.Contains("presentation")) return "ðŸ“½";
        if (contentType.Contains("text")) return "ðŸ“ƒ";
        if (contentType.Contains("zip") || contentType.Contains("rar") ||
            contentType.Contains("7z") || contentType.Contains("tar") ||
            contentType.Contains("gzip")) return "ðŸ“¦";
        
        return "ðŸ“Ž";
    }

    private bool CanSendMessage()
    {
        return !string.IsNullOrWhiteSpace(newMessage) || selectedFiles.Any();
    }

    private void OpenGroupSettings()
    {
        if (Channel != null)
        {
            OnOpenGroupSettings.InvokeAsync(Channel);
        }
    }

    public async ValueTask DisposeAsync()
    {
        ChatService.OnMessageReceived -= HandleMessageReceived;
        ChatService.OnUserTyping -= HandleUserTyping;
        ChatService.OnUserStatusChanged -= HandleUserStatusChanged;
        typingTimer?.Dispose();
        if (_currentChannelId > 0)
        {
            await ChatService.LeaveChannelAsync(_currentChannelId);
        }
    }
}
