@using SharpTalk.Shared.DTOs
@using SharpTalk.Web.Services
@using System.Security.Claims
@using Microsoft.AspNetCore.Components.Authorization
@using Microsoft.AspNetCore.Components.Forms
@implements IAsyncDisposable
@inject ChatService ChatService
@inject AuthenticationStateProvider AuthStateProvider
@inject IJSRuntime JSRuntime
@inject UrlUtilityService UrlUtilityService

<div class="chat-area">
    <div class="messages-list" id="messagesList">
        @foreach (var msg in Messages)
        {
            var isMine = msg.UserId == currentUserId;
            <div class='message-item @(isMine ? "message-mine" : "message-others")'>
                <img src="@UrlUtilityService.GetAvatarUrl(msg.AvatarUrl)"
                     class="message-avatar"
                     alt="@msg.Username" />
                <div class="message-body">
                    <div class="message-info">
                        <span class="message-author">@msg.Username</span>
                        <span class="message-timestamp">@msg.Timestamp.ToLocalTime().ToString("t")</span>
                    </div>
                    <div class="bubble-container">
                        <div class="message-content">@msg.Content</div>
                        @if (msg.Attachments.Any())
                        {
                            <div class="message-attachments">
                                @foreach (var attachment in msg.Attachments)
                                {
                                    <div class="attachment-item">
                                        @if (IsImage(attachment.FileType))
                                        {
                                            <img src="@UrlUtilityService.GetFileUrl(attachment.FileUrl)"
                                                 class="attachment-image"
                                                 alt="@attachment.FileName"
                                                 @onclick="() => OpenImagePreview(attachment)" />
                                        }
                                        else
                                        {
                                            <div class="attachment-file" @onclick="() => DownloadFile(attachment)">
                                                <span class="file-icon">@GetFileIcon(attachment.FileType)</span>
                                                <div class="file-info">
                                                    <span class="file-name">@attachment.FileName</span>
                                                    <span class="file-size">@FormatFileSize(attachment.FileSize)</span>
                                                </div>
                                            </div>
                                        }
                                    </div>
                                }
                            </div>
                        }
                    </div>
                </div>
            </div>
        }
    </div>

    <div class="typing-indicator">
        @if (TypingUsers.Any())
        {
            <small class="text-muted italic">
                @(string.Join(", ", TypingUsers.Values)) @(TypingUsers.Count == 1 ? "is" : "are") typing...
            </small>
        }
    </div>

    <div class="message-input">
        @if (selectedFiles.Any())
        {
            <div class="file-preview-area">
                @foreach (var file in selectedFiles)
                {
                    <div class="file-preview-card">
                        <div class="file-preview-icon @GetFileIconClass(file.ContentType)">
                            <span>@GetFileIconEmoji(file.ContentType)</span>
                        </div>
                        <div class="file-preview-info">
                            <span class="file-preview-name" title="@file.Name">@file.Name</span>
                            <span class="file-preview-size">@FormatFileSize(file.Size)</span>
                        </div>
                        <button type="button" class="file-preview-remove" @onclick="() => RemoveFile(file)" title="Remove file">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <line x1="18" y1="6" x2="6" y2="18"></line>
                                <line x1="6" y1="6" x2="18" y2="18"></line>
                            </svg>
                        </button>
                    </div>
                }
            </div>
        }
        <form @onsubmit="SendMessage">
            <div class="chat-input-container">
                <label class="attach-btn" title="Attach files">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M21.44 11.05l-9.19 9.19a6 6 0 0 1-8.49-8.49l9.19-9.19a4 4 0 0 1 5.66 5.66l-9.2 9.19a2 2 0 0 1-2.83-2.83l8.49-8.48"></path>
                    </svg>
                    <InputFile OnChange="HandleFileSelect" multiple />
                </label>
                <input type="text" class="message-input-field" placeholder="Message #Channel" @bind="newMessage"
                    @bind:event="oninput" />
                <button type="submit" class="send-btn" title="Send message" disabled="@(!CanSendMessage())">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <line x1="22" y1="2" x2="11" y2="13"></line>
                        <polygon points="22 2 15 22 11 13 2 9 22 2"></polygon>
                    </svg>
                </button>
            </div>
        </form>
    </div>
</div>

<!-- Image Preview Modal -->
@if (previewAttachment != null)
{
    <div class="image-preview-modal" @onclick="CloseImagePreview">
        <div class="image-preview-content" @onclick:stopPropagation>
            <img src="@UrlUtilityService.GetFileUrl(previewAttachment.FileUrl)" alt="@previewAttachment.FileName" />
            <div class="image-preview-actions">
                <button type="button" class="btn btn-secondary" @onclick="CloseImagePreview">Close</button>
                <button type="button" class="btn btn-primary" @onclick="() => DownloadFile(previewAttachment)">Download</button>
            </div>
        </div>
    </div>
}

@code {
    [Parameter]
    public int ChannelId { get; set; }

    private List<MessageDto> Messages = new List<MessageDto>();
    private string _newMessage = string.Empty;
    private string newMessage
    {
        get => _newMessage;
        set
        {
            if (_newMessage != value)
            {
                _newMessage = value;
                HandleTyping();
            }
        }
    }
    private int _currentChannelId;
    private int currentUserId;
    private Dictionary<int, string> TypingUsers = new Dictionary<int, string>();
    private System.Timers.Timer? typingTimer;
    private bool isTypingSent = false;
    private List<IBrowserFile> selectedFiles = new List<IBrowserFile>();
    private List<AttachmentDto> uploadedAttachments = new List<AttachmentDto>();
    private bool isUploading = false;
    private AttachmentDto? previewAttachment;

    protected override async Task OnInitializedAsync()
    {
        var authState = await AuthStateProvider.GetAuthenticationStateAsync();
        var userIdStr = authState.User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
        int.TryParse(userIdStr, out currentUserId);

        ChatService.OnMessageReceived += HandleMessageReceived;
        ChatService.OnUserTyping += HandleUserTyping;
        await ChatService.InitializeAsync();
    }

    protected override async Task OnParametersSetAsync()
    {
        if (ChannelId != _currentChannelId)
        {
            if (_currentChannelId > 0)
            {
                await ChatService.LeaveChannelAsync(_currentChannelId);
            }

            _currentChannelId = ChannelId;
            Messages.Clear();

            // Only load history and join if channel ID is valid
            if (ChannelId > 0)
            {
                // Load history
                var history = await ChatService.GetMessageHistoryAsync(ChannelId);
                Messages.AddRange(history);
                StateHasChanged();

                await ChatService.JoinChannelAsync(ChannelId);
            }
        }
    }

    private async void HandleMessageReceived(MessageDto message)
    {
        if (message.ChannelId == ChannelId)
        {
            Messages.Add(message);
            // Clear typing indicator for this user if it exists
            if (TypingUsers.ContainsKey(message.UserId))
            {
                TypingUsers.Remove(message.UserId);
            }
            await InvokeAsync(StateHasChanged);
        }
    }

    private async void HandleUserTyping(int channelId, int userId, string username, bool isTyping)
    {
        if (channelId == ChannelId)
        {
            if (isTyping)
            {
                if (!TypingUsers.ContainsKey(userId))
                {
                    TypingUsers[userId] = username;
                }
            }
            else
            {
                TypingUsers.Remove(userId);
            }
            await InvokeAsync(StateHasChanged);
        }
    }

    private void HandleTyping()
    {
        // Prevent sending typing indicators to invalid channel (0)
        if (ChannelId <= 0 || string.IsNullOrWhiteSpace(newMessage)) return;

        if (!isTypingSent)
        {
            isTypingSent = true;
            _ = ChatService.SendTypingIndicatorAsync(ChannelId, true);
        }

        if (typingTimer == null)
        {
            typingTimer = new System.Timers.Timer(3000);
            typingTimer.AutoReset = false;
            typingTimer.Elapsed += async (s, args) =>
            {
                isTypingSent = false;
                await ChatService.SendTypingIndicatorAsync(ChannelId, false);
                await InvokeAsync(StateHasChanged);
            };
        }
        else
        {
            typingTimer.Stop();
        }
        typingTimer.Start();
    }

    private async Task SendMessage()
    {
        // Prevent sending messages to invalid channel (0)
        if (ChannelId <= 0)
        {
            return;
        }

        if (!string.IsNullOrWhiteSpace(newMessage) || selectedFiles.Any())
        {
            var content = newMessage;
            newMessage = string.Empty;
            isTypingSent = false;
            typingTimer?.Stop();

            // Upload files first if any
            List<int> attachmentIds = new List<int>();
            if (selectedFiles.Any())
            {
                isUploading = true;
                StateHasChanged();

                uploadedAttachments = await ChatService.UploadFilesAsync(selectedFiles, ChannelId);
                attachmentIds = uploadedAttachments.Select(a => a.Id).ToList();

                selectedFiles.Clear();
                isUploading = false;
            }

            await ChatService.SendMessageAsync(ChannelId, content, attachmentIds);
            await ChatService.SendTypingIndicatorAsync(ChannelId, false);
        }
    }

    private async void HandleFileSelect(InputFileChangeEventArgs e)
    {
        foreach (var file in e.GetMultipleFiles())
        {
            // Validate file size
            var maxSize = file.ContentType.StartsWith("image/") ? 5 * 1024 * 1024 : 10 * 1024 * 1024;
            if (file.Size > maxSize)
            {
                continue; // Skip files that are too large
            }

            selectedFiles.Add(file);
        }
        StateHasChanged();
    }

    private void RemoveFile(IBrowserFile file)
    {
        selectedFiles.Remove(file);
        StateHasChanged();
    }

    private void OpenImagePreview(AttachmentDto attachment)
    {
        previewAttachment = attachment;
        StateHasChanged();
    }

    private void CloseImagePreview()
    {
        previewAttachment = null;
        StateHasChanged();
    }

    private async void DownloadFile(AttachmentDto attachment)
    {
        var downloadUrl = await ChatService.DownloadAttachmentAsync(attachment.Id);
        if (!string.IsNullOrEmpty(downloadUrl))
        {
            await JSRuntime.InvokeVoidAsync("downloadFile", downloadUrl, attachment.FileName);
        }
    }

    private bool IsImage(string fileType)
    {
        return fileType.StartsWith("image/");
    }

    private string GetFileIcon(string fileType)
    {
        return fileType switch
        {
            var f when f.StartsWith("image/") => "ðŸ–¼ï¸",
            var f when f.Contains("pdf") => "ðŸ“„",
            var f when f.Contains("word") => "ðŸ“",
            var f when f.Contains("excel") || f.Contains("spreadsheet") => "ðŸ“Š",
            var f when f.Contains("powerpoint") || f.Contains("presentation") => "ðŸ“½",
            var f when f.Contains("zip") || f.Contains("rar") || f.Contains("7z") => "ðŸ“¦",
            var f when f.Contains("text") => "ðŸ“ƒ",
            _ => "ðŸ“Ž"
        };
    }

    private string FormatFileSize(long bytes)
    {
        string[] sizes = { "B", "KB", "MB", "GB" };
        int order = 0;
        double size = bytes;
        while (size >= 1024 && order < sizes.Length - 1)
        {
            order++;
            size = size / 1024;
        }
        return $"{size:0.##} {sizes[order]}";
    }

    private string GetFileIconClass(string? contentType)
    {
        if (string.IsNullOrEmpty(contentType)) return "default";
        
        if (contentType.StartsWith("image/")) return "image";
        if (contentType.Contains("pdf")) return "pdf";
        if (contentType.Contains("word") || contentType.Contains("document") ||
            contentType.Contains("excel") || contentType.Contains("spreadsheet") ||
            contentType.Contains("powerpoint") || contentType.Contains("presentation") ||
            contentType.Contains("text")) return "document";
        if (contentType.Contains("zip") || contentType.Contains("rar") ||
            contentType.Contains("7z") || contentType.Contains("tar") ||
            contentType.Contains("gzip")) return "archive";
        
        return "default";
    }

    private string GetFileIconEmoji(string? contentType)
    {
        if (string.IsNullOrEmpty(contentType)) return "ðŸ“Ž";
        
        if (contentType.StartsWith("image/")) return "ðŸ–¼ï¸";
        if (contentType.Contains("pdf")) return "ðŸ“„";
        if (contentType.Contains("word") || contentType.Contains("document")) return "ðŸ“";
        if (contentType.Contains("excel") || contentType.Contains("spreadsheet")) return "ðŸ“Š";
        if (contentType.Contains("powerpoint") || contentType.Contains("presentation")) return "ðŸ“½";
        if (contentType.Contains("text")) return "ðŸ“ƒ";
        if (contentType.Contains("zip") || contentType.Contains("rar") ||
            contentType.Contains("7z") || contentType.Contains("tar") ||
            contentType.Contains("gzip")) return "ðŸ“¦";
        
        return "ðŸ“Ž";
    }

    private bool CanSendMessage()
    {
        return !string.IsNullOrWhiteSpace(newMessage) || selectedFiles.Any();
    }

    public async ValueTask DisposeAsync()
    {
        ChatService.OnMessageReceived -= HandleMessageReceived;
        ChatService.OnUserTyping -= HandleUserTyping;
        typingTimer?.Dispose();
        if (_currentChannelId > 0)
        {
            await ChatService.LeaveChannelAsync(_currentChannelId);
        }
    }
}
